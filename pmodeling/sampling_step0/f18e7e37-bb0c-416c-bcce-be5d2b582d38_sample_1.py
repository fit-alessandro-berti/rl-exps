A = Transition(label='A')
B = Transition(label='B')
C = Transition(label='C')
D = Transition(label='D')
E = Transition(label='E')
F = Transition(label='F')
G = Transition(label='G')
H = Transition(label='H')
I = Transition(label='I')
J = Transition(label='J')
K = Transition(label='K')
L = Transition(label='L')
M = Transition(label='M')
N = Transition(label='N')
O = Transition(label='O')
P = Transition(label='P')
Q = Transition(label='Q')
R = Transition(label='R')
S = Transition(label='S')
T = Transition(label='T')
U = Transition(label='U')
V = Transition(label='V')
W = Transition(label='W')
X = Transition(label='X')
Y = Transition(label='Y')
Z = Transition(label='Z')
skip = SilentTransition()

# Define the partial order
root = StrictPartialOrder(nodes=[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z])

# Define the partial order relationships
root.order.add_edge(A, B)
root.order.add_edge(B, C)
root.order.add_edge(C, D)
root.order.add_edge(D, E)
root.order.add_edge(E, F)
root.order.add_edge(F, G)
root.order.add_edge(G, H)
root.order.add_edge(H, I)
root.order.add_edge(I, J)
root.order.add_edge(J, K)
root.order.add_edge(K, L)
root.order.add_edge(L, M)
root.order.add_edge(M, N)
root.order.add_edge(N, O)
root.order.add_edge(O, P)
root.order.add_edge(P, Q)
root.order.add_edge(Q, R)
root.order.add_edge(R, S)
root.order.add_edge(S, T)
root.order.add_edge(T, U)
root.order.add_edge(U, V)
root.order.add_edge(V, W)
root.order.add_edge(W, X)
root.order.add_edge(X, Y)
root.order.add_edge(Y, Z)

# Define the choice operators
choice1 = OperatorPOWL(operator=Operator.XOR, children=[A, B])
choice2 = OperatorPOWL(operator=Operator.XOR, children=[C, D])
choice3 = OperatorPOWL(operator=Operator.XOR, children=[E, F])
choice4 = OperatorPOWL(operator=Operator.XOR, children=[G, H])
choice5 = OperatorPOWL(operator=Operator.XOR, children=[I, J])
choice6 = OperatorPOWL(operator=Operator.XOR, children=[K, L])
choice7 = OperatorPOWL(operator=Operator.XOR, children=[M, N])
choice8 = OperatorPOWL(operator=Operator.XOR, children=[O, P])
choice9 = OperatorPOWL(operator=Operator.XOR, children=[Q, R])
choice10 = OperatorPOWL(operator=Operator.XOR, children=[S, T])
choice11 = OperatorPOWL(operator=Operator.XOR, children=[U, V])
choice12 = OperatorPOWL(operator=Operator.XOR, children=[W, X])
choice13 = OperatorPOWL(operator=Operator.XOR, children=[Y, Z])

# Define the loop operators
loop1 = OperatorPOWL(operator=Operator.LOOP, children=[choice1, choice2])
loop2 = OperatorPOWL(operator=Operator.LOOP, children=[choice3, choice4])
loop3 = OperatorPOWL(operator=Operator.LOOP, children=[choice5, choice6])
loop4 = OperatorPOWL(operator=Operator.LOOP, children=[choice7, choice8])
loop5 = OperatorPOWL(operator=Operator.LOOP, children=[choice9, choice10])
loop6 = OperatorPOWL(operator=Operator.LOOP, children=[choice11, choice12])
loop7 = OperatorPOWL(operator=Operator.LOOP, children=[choice13, choice14])

# Define the final POWL model
final_model = StrictPartialOrder(nodes=[loop1, loop2, loop3, loop4, loop5, loop6, loop7])
final_model.order.add_edge(loop1, loop2)
final_model.order.add_edge(loop2, loop3)
final_model.order.add_edge(loop3, loop4)
final_model.order.add_edge(loop4, loop5)
final_model.order.add_edge(loop5, loop6)
final_model.order.add_edge(loop6, loop7)

# Print the final POWL model
print(final_model)